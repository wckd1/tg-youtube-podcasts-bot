package usecase

import (
	"encoding/xml"
	"errors"
	"log"
	"wckd1/tg-youtube-podcasts-bot/internal/converter"
	"wckd1/tg-youtube-podcasts-bot/internal/domain/entity"
	"wckd1/tg-youtube-podcasts-bot/internal/domain/repository"
)

var (
	ErrGetEpisodes = errors.New("failed to get playlist episodes")
	ErrXMLEncoding = errors.New("failed to build xml")
)

type RSSUseCase struct {
	playlistRepository repository.PlaylistRepository
	episodeRepository  repository.EpisodeRepository
}

func NewRSSUseCase(playlistRepository repository.PlaylistRepository, episodeRepository repository.EpisodeRepository) *RSSUseCase {
	return &RSSUseCase{playlistRepository, episodeRepository}
}

// TODO: Return playlist with episodes, bultd xml on delivery layer
func (uc RSSUseCase) BuildRSS(plID string) (string, error) {
	// Get playlist
	pl, err := uc.playlistRepository.GetPlaylist(plID)
	if err != nil {
		return "", errors.Join(ErrGetEpisodes, err)
	}
	items := make([]entity.RSSEpisode, 0)

	// Get playlist's episodes
	for _, epID := range pl.Episodes() {
		ep, err := uc.episodeRepository.GetEpisode(epID)
		if err != nil {
			log.Printf("[ERROR] Can't get episode, %+v", err)
			continue
		}
		items = append(items, converter.EpisodeToRSSEpisode(&ep))
	}

	// Get playlist's information
	title := pl.Name()
	if title == entity.DefaultPlaylistName {
		title = "Private RSS feed"
	}

	// Build RSS
	rss := entity.RSS{
		Version:        "2.0",
		NsItunes:       "http://www.itunes.com/dtds/podcast-1.0.dtd",
		Title:          title,
		Description:    "Generated by tg-youtube-podcasts-bot",
		Image:          "https://www.clipartkey.com/mpngs/m/197-1971515_youtube-music-seamless-audio-video-switching-transparent-youtube.png",
		Language:       "ru",
		ItunesExplicit: "false",
		Category:       "Education",
		ItemList:       items,
	}

	b, err := xml.MarshalIndent(&rss, "", "  ")
	if err != nil {
		return "", errors.Join(ErrXMLEncoding, err)
	}

	res := `<?xml version="1.0" encoding="UTF-8"?>` + "\n" + string(b)
	return res, nil
}
